---
title: "Pandas - All You Need To Know"
date: 2022-04-30
categories:
  - Pythonic ideas
tags: [Coding]
header:
  image: "/images/2020-03-17-compilation_cython/yancy-min-842ofHC6MaI-unsplash.jpg"
excerpt: "An exhaustive tutorial on data wrangling & analysis with Pandas"
mathjax: "true"
---


I've already done the same thing with [Numpy](https://obrunet.github.io/pythonic%20ideas/numpy/), so i've decided to create a cheat-sheet for Pandas too :) Most of what you'll find below is taken from Khalil El Mahrsi's course that you can find on his website [smellydatascience.com](https://smellydatascience.com/teaching/python-for-data-science-2021/02-numpy.html) published under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License (CC BY-NC-SA 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/). So all the credits goes to him. I've added few tips found here and there... 

You'll also found my [Anki decks](https://github.com/obrunet/Memory_systems_-_Anki_decks/tree/master/01.My_own_decks/Programming_languages) related to Numpy & Pandas on github. 

# Introduction

- a Python package for tabular data analysis and manipulation
- powerful & intuitive : fast, flexible and easy to use
- open source

Tabular data definition:  
data structured into a table (dataframe) ie into rows & columns
- row: entities, objects, observations, instances
- column: variables, features, attibutes 

Variable types

![title](/images/2022-04-30-pandas/01.var_types.png)   

Quantitative (Numerical) Variables
- A quantitative variable has values that are numeric and that reflect a notion of magnitude
- Quantitative variables can be
    - Discrete → finite set of countable values (often integers)  
        e.g., number of children per family, number of rooms in a house, ...
    - Continuous → infinity of possible values  
        e.g., age, height, weight, distance, date and time, ...
- Math operations on quantitative variables make sense  
    e.g., a person who has 4 children has twice as much children as a person who has 2
    
Qualitative (Categorical) Variables
- A qualitative variable's values represent categories (modalities, levels)
- They do not represent quantities or orders of magnitude
- Qualitative variables can be
    - Nominal → modalities are unordered
        e.g., color,
    - Ordinal → an order exists between modalities
        e.g., cloth sizes (XS, S, M, L, XL, XXL, ...), satisfaction level (very dissatisfied, dissatisfied, neutral, satisfied, very satisfied), ...
        
        
/!\ Encoding a categorical variable with a numeric data type (e.g., int) does not make it quantitative!

Pandas' Features  
- Based on NumPy → many concepts (indexing, slicing, ...) work similarly
- Two main object types
    - DataFrame → 2-dimensional data structure storing data of different types (strings, integers, floats, ...) in columns
    - Series → represents a column (series of values)
    
Installing & importing pandas  

!conda install pandas  
!pip install pandas  



```python
import pandas as pd
```

# Basic Functionalities

dataset used for the below examples: [The Bank Marketing Data Set](https://archive.ics.uci.edu/ml/datasets/Bank%2BMarketing)
Variables
- age: age in years (numeric)
- job: the customer's job category (categorical)
- marital:the customer's marital status (categorical)
- education: the customer's education level (ordinal)
- default: whether the customer has a loan in default (categorical)
- housing: whether the customer has a housing loan (categorical)
- loan: whether the customer has a presonal loan (categorical)  
...
- y: how the customer responded to a marketing campaign (target variable)

Pandas provides __reader__ and __writer functions for handling popular formats__: CSV, JSON, parquet, Excel, SQL databases...  

reader function to load a data frame from a CSV file


```python
# df = pd.read_csv(file_path, sep=separator,...) 
# default sep = ","
df = pd.read_csv("./bank.csv", sep=';')
```


```python
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2</th>
      <td>35</td>
      <td>management</td>
      <td>single</td>
      <td>tertiary</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30</td>
      <td>management</td>
      <td>married</td>
      <td>tertiary</td>
      <td>no</td>
      <td>1476</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4</th>
      <td>59</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>0</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>5</td>
      <td>may</td>
      <td>226</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.to_csv("bank_copy.csv")
#!dir or !ls -alh
```

view the beginning or the end of a series / dataframe


```python
df.head(2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.tail(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4518</th>
      <td>57</td>
      <td>technician</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>295</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>aug</td>
      <td>151</td>
      <td>11</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4519</th>
      <td>28</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>1137</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>6</td>
      <td>feb</td>
      <td>129</td>
      <td>4</td>
      <td>211</td>
      <td>3</td>
      <td>other</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4520</th>
      <td>44</td>
      <td>entrepreneur</td>
      <td>single</td>
      <td>tertiary</td>
      <td>no</td>
      <td>1136</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>3</td>
      <td>apr</td>
      <td>345</td>
      <td>2</td>
      <td>249</td>
      <td>7</td>
      <td>other</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



get the shape of a DataFrame or a Series  
- DataFrame → tuple (__row_count, column_count__)
- Series → singleton tuple (__length__, )


```python
df.shape
```




    (4521, 17)



The column names of a DataFrame can be accessed using its columns attribute



```python
df.columns
```




    Index(['age', 'job', 'marital', 'education', 'default', 'balance', 'housing',
           'loan', 'contact', 'day', 'month', 'duration', 'campaign', 'pdays',
           'previous', 'poutcome', 'y'],
          dtype='object')



Use the dtypes attribute to check the data types of a Series or a DataFrame's columns  
- pandas mostly relies on NumPy arrays and dtypes (__bool, int, float, datetime64[ns], ...__)
- pandas also extends some NumPy types (__CategoricalDtype, DatetimeTZDtype, ...__)
- Two ways to represent strings: __object__ dtype (default) or __StringDtype__ (recommended)


```python
df.dtypes
```




    age           int64
    job          object
    marital      object
    education    object
    default      object
    balance       int64
    housing      object
    loan         object
    contact      object
    day           int64
    month        object
    duration      int64
    campaign      int64
    pdays         int64
    previous      int64
    poutcome     object
    y            object
    dtype: object



__Technical summary__  
A technical summary of a DataFrame can be accessed using the __info()__ method.
It contains
- The type of the DataFrame
- The row index (__RangeIndex__ in the example) and its number of entries
- The total number of columns
- For each column
    -The column's name
    - The count of non-null values
    - The column's data type
- Column count per data type
- Total memory usage


```python
df.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 4521 entries, 0 to 4520
    Data columns (total 17 columns):
     #   Column     Non-Null Count  Dtype 
    ---  ------     --------------  ----- 
     0   age        4521 non-null   int64 
     1   job        4521 non-null   object
     2   marital    4521 non-null   object
     3   education  4521 non-null   object
     4   default    4521 non-null   object
     5   balance    4521 non-null   int64 
     6   housing    4521 non-null   object
     7   loan       4521 non-null   object
     8   contact    4521 non-null   object
     9   day        4521 non-null   int64 
     10  month      4521 non-null   object
     11  duration   4521 non-null   int64 
     12  campaign   4521 non-null   int64 
     13  pdays      4521 non-null   int64 
     14  previous   4521 non-null   int64 
     15  poutcome   4521 non-null   object
     16  y          4521 non-null   object
    dtypes: int64(7), object(10)
    memory usage: 600.6+ KB
    

__Statistical Summary of Numerical Columns__  
Use the __describe()__ method to access a statistical summary (mean, standard deviation, min, max, ...) of numerical columns of a DataFrame


```python
# transpose the statistical summary for better readability
df.describe().T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>age</th>
      <td>4521.0</td>
      <td>41.170095</td>
      <td>10.576211</td>
      <td>19.0</td>
      <td>33.0</td>
      <td>39.0</td>
      <td>49.0</td>
      <td>87.0</td>
    </tr>
    <tr>
      <th>balance</th>
      <td>4521.0</td>
      <td>1422.657819</td>
      <td>3009.638142</td>
      <td>-3313.0</td>
      <td>69.0</td>
      <td>444.0</td>
      <td>1480.0</td>
      <td>71188.0</td>
    </tr>
    <tr>
      <th>day</th>
      <td>4521.0</td>
      <td>15.915284</td>
      <td>8.247667</td>
      <td>1.0</td>
      <td>9.0</td>
      <td>16.0</td>
      <td>21.0</td>
      <td>31.0</td>
    </tr>
    <tr>
      <th>duration</th>
      <td>4521.0</td>
      <td>263.961292</td>
      <td>259.856633</td>
      <td>4.0</td>
      <td>104.0</td>
      <td>185.0</td>
      <td>329.0</td>
      <td>3025.0</td>
    </tr>
    <tr>
      <th>campaign</th>
      <td>4521.0</td>
      <td>2.793630</td>
      <td>3.109807</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>50.0</td>
    </tr>
    <tr>
      <th>pdays</th>
      <td>4521.0</td>
      <td>39.766645</td>
      <td>100.121124</td>
      <td>-1.0</td>
      <td>-1.0</td>
      <td>-1.0</td>
      <td>-1.0</td>
      <td>871.0</td>
    </tr>
    <tr>
      <th>previous</th>
      <td>4521.0</td>
      <td>0.542579</td>
      <td>1.693562</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>25.0</td>
    </tr>
  </tbody>
</table>
</div>



__Value Counts of Qualitative Columns__  
Use the __value_counts()__ method to count the number of occurrences of each value in a Series (or DataFrame). Use __normalize=True__ in the method call to get percentages


```python
# count occurences of each category of marital
# (can also be used with numerical variables)

df['marital'].value_counts()
```




    married     2797
    single      1196
    divorced     528
    Name: marital, dtype: int64




```python
# percentages instead of counts

df['marital'].value_counts(normalize=True)
```




    married     0.618668
    single      0.264543
    divorced    0.116788
    Name: marital, dtype: float64




```python
# for a DF, value_counts() counts occurences
# of rows (i.e., value combinations)

df[['marital', 'housing']].value_counts()
```




    marital   housing
    married   yes        1625
              no         1172
    single    yes         636
              no          560
    divorced  yes         298
              no          230
    dtype: int64



__Selecting a Single Column__  
To select a single column from a DataFrame, specify its name within square brackets → __df[col]__. The retrieved object is a __Series__.


```python
jobs = df['job']
type(jobs)
```




    pandas.core.series.Series




```python
jobs.head()
```




    0     unemployed
    1       services
    2     management
    3     management
    4    blue-collar
    Name: job, dtype: object



__Selecting Multiple Columns__  
To select multiple columns, provide a list of column names within square brackets → __df[[col_1, col_2, ...]]__. The retrieved object is a __DataFrame__


```python
df[['age', 'education', 'job', 'loan']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>education</th>
      <th>job</th>
      <th>loan</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>primary</td>
      <td>unemployed</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>secondary</td>
      <td>services</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>2</th>
      <td>35</td>
      <td>tertiary</td>
      <td>management</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30</td>
      <td>tertiary</td>
      <td>management</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>4</th>
      <td>59</td>
      <td>secondary</td>
      <td>blue-collar</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



__Dropping Columns__  
Instead of selecting columns, you can drop unwanted columns using the __drop()__ method. Be sure to specify __axis=1__ (otherwise, will attempt to drop rows)
To modify the original data frame, use __inplace=True__ in the method call


```python
df_with_cols_dropped = df.drop(['balance', 'day', 'month', 
                                'duration', 'pdays'], axis=1)
df_with_cols_dropped.tail(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>campaign</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4518</th>
      <td>57</td>
      <td>technician</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>11</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4519</th>
      <td>28</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>4</td>
      <td>3</td>
      <td>other</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4520</th>
      <td>44</td>
      <td>entrepreneur</td>
      <td>single</td>
      <td>tertiary</td>
      <td>no</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>2</td>
      <td>7</td>
      <td>other</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



__Why Select Columns?__
Two main motivations for selecting or dropping columns
- Restrict the data to meaningful variables that are useful for the intended data analysis
- Retaining variables that are compatible with some technique you intend to use e.g., some machine learning algorithms only make sense when applied to numerical variables

__Filtering Rows__
Rows can be removed using a boolean filter → __df[bool_filter]__
- Filter contains __True__ at position __i__ → keep corresponding row
- Filter contains __False__ at position __i__ → remove corresponding row
Most of the time, the filter involves conditions on the columns
- e.g., keep married clients only
- e.g., keep clients who are 30 or older
- etc.
Conditions can be combined using logical operators
- __&__ → bit-wise logical and (binary)
- __|__ → bit-wise logical or (binary)
- __~__ → bit-wise logical negation (unary)


Example: clients who are married or divorced, unemployed, and 40 or older

Each condition produces a pandas Series. The different conditions' Series are then combined into one Series used to filter the rows.


```python
df[
    ((df['marital'] == 'married') | (df['marital'] == 'divorced')) &
    (df['age'] >= 40) & (df['job'] == 'unemployed')
].head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>79</th>
      <td>40</td>
      <td>unemployed</td>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
      <td>219</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>17</td>
      <td>nov</td>
      <td>204</td>
      <td>2</td>
      <td>196</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>108</th>
      <td>56</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>no</td>
      <td>3391</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>21</td>
      <td>apr</td>
      <td>243</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>152</th>
      <td>45</td>
      <td>unemployed</td>
      <td>divorced</td>
      <td>primary</td>
      <td>yes</td>
      <td>-249</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>1</td>
      <td>jul</td>
      <td>92</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



__Why Filter Rows?__  
Filtering rows can be motivated by multiple reasons
- Limiting the analysis to a specific subpopulation of interest
- Handling outliers and missing values (drop problematic rows)
- Performance considerations (subsampling a massive data set)

/!\ Never filter rows (or select columns) using for loops!

__Sorting Data__  
Use the __sort_values()__ method to sort a __DataFrame__ or a __Series__
- Data frames can be sorted on multiple columns by providing the list of column 
names
- Sorting order (ascending or descending) can be controlled with the __ascending argument__
- Use __inplace=True__ in the method call to modify the original DataFrame or Series


```python
df.sort_values(by='age').head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>503</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>primary</td>
      <td>no</td>
      <td>103</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>10</td>
      <td>jul</td>
      <td>104</td>
      <td>2</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>1900</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>0</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>11</td>
      <td>feb</td>
      <td>123</td>
      <td>3</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2780</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>302</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>jul</td>
      <td>205</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>3233</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>1169</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>6</td>
      <td>feb</td>
      <td>463</td>
      <td>18</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>999</th>
      <td>20</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>291</td>
      <td>no</td>
      <td>no</td>
      <td>telephone</td>
      <td>11</td>
      <td>may</td>
      <td>172</td>
      <td>5</td>
      <td>371</td>
      <td>5</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1725</th>
      <td>20</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>1191</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>12</td>
      <td>feb</td>
      <td>274</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>13</th>
      <td>20</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>502</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>30</td>
      <td>apr</td>
      <td>261</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>3362</th>
      <td>21</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>6</td>
      <td>no</td>
      <td>no</td>
      <td>unknown</td>
      <td>9</td>
      <td>may</td>
      <td>622</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2289</th>
      <td>21</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>681</td>
      <td>no</td>
      <td>no</td>
      <td>unknown</td>
      <td>20</td>
      <td>aug</td>
      <td>6</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>110</th>
      <td>21</td>
      <td>student</td>
      <td>single</td>
      <td>secondary</td>
      <td>no</td>
      <td>2488</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>30</td>
      <td>jun</td>
      <td>258</td>
      <td>6</td>
      <td>169</td>
      <td>3</td>
      <td>success</td>
      <td>yes</td>
    </tr>
  </tbody>
</table>
</div>



Example: sort the data frame by decreasing alphabetical order of marital status and education, and increasing order of age


/!\ While education is an ordinal variable, pandas sorts it alphabetically since it is encoded as a string!


```python
df.sort_values(by=['marital', 'education', 'age'],
              ascending=[False, False, True]).head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1900</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>0</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>11</td>
      <td>feb</td>
      <td>123</td>
      <td>3</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3233</th>
      <td>19</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>1169</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>6</td>
      <td>feb</td>
      <td>463</td>
      <td>18</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2703</th>
      <td>21</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>137</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>12</td>
      <td>may</td>
      <td>198</td>
      <td>3</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1241</th>
      <td>22</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>549</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>2</td>
      <td>sep</td>
      <td>154</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1543</th>
      <td>22</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>47</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>3</td>
      <td>jul</td>
      <td>69</td>
      <td>3</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2565</th>
      <td>23</td>
      <td>blue-collar</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>817</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>18</td>
      <td>may</td>
      <td>123</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2621</th>
      <td>24</td>
      <td>blue-collar</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>431</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>108</td>
      <td>12</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3200</th>
      <td>24</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>3298</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>28</td>
      <td>may</td>
      <td>227</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1870</th>
      <td>25</td>
      <td>student</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>10788</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>23</td>
      <td>dec</td>
      <td>102</td>
      <td>2</td>
      <td>210</td>
      <td>2</td>
      <td>other</td>
      <td>no</td>
    </tr>
    <tr>
      <th>357</th>
      <td>27</td>
      <td>management</td>
      <td>single</td>
      <td>unknown</td>
      <td>no</td>
      <td>3196</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>9</td>
      <td>feb</td>
      <td>10</td>
      <td>2</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



# Indexing Rows and Columns

Two main ways for indexing data frames

- Label-based indexing with __.loc__
    - A label-based index can be
    - A single label (e.g., __"age"__)
    - A list or array of labels (e.g., __["age", "job", "loan"]__)
    - A slice with labels (e.g., __"age":"balance"__)
    - A boolean array or list
- Position-based indexing with __.iloc__
- Similar to NumPy arrays indexing
    - A position-based index can be
    - An integer (e.g., __4__)
    - A list or array of integers (e.g., __[4, 2, 10]__)
    - A slice with integers (e.g., 2:10:2)
    - A boolean array or list
- If you don't want to index a dimension, leave its index empty or replace it with a colon (__:__)

label-based indexing with .loc


```python
df.loc[row_lab_idx, col_lab_idx]
```

position-based indexing with .iloc


```python
df._loc[row_pos_idx, col_pos_idx]
```

get the first 10 rows and only columns at positions 2 to 4 (5 is excluded)


```python
df.iloc[:10, 2:5]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>primary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1</th>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2</th>
      <td>single</td>
      <td>tertiary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3</th>
      <td>married</td>
      <td>tertiary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>4</th>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>5</th>
      <td>single</td>
      <td>tertiary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>6</th>
      <td>married</td>
      <td>tertiary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>7</th>
      <td>married</td>
      <td>secondary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>8</th>
      <td>married</td>
      <td>tertiary</td>
      <td>no</td>
    </tr>
    <tr>
      <th>9</th>
      <td>married</td>
      <td>primary</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



using .loc to get rows and columns by label


```python
df.loc[[1, 3, 5, 10, 20], ["job", "marital", "poutcome"]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>job</th>
      <th>marital</th>
      <th>poutcome</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>services</td>
      <td>married</td>
      <td>failure</td>
    </tr>
    <tr>
      <th>3</th>
      <td>management</td>
      <td>married</td>
      <td>unknown</td>
    </tr>
    <tr>
      <th>5</th>
      <td>management</td>
      <td>single</td>
      <td>failure</td>
    </tr>
    <tr>
      <th>10</th>
      <td>services</td>
      <td>married</td>
      <td>unknown</td>
    </tr>
    <tr>
      <th>20</th>
      <td>management</td>
      <td>divorced</td>
      <td>unknown</td>
    </tr>
  </tbody>
</table>
</div>



label slices include the end label !


```python
df.loc[:, "balance":"duration"].head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
    </tr>
  </tbody>
</table>
</div>



## Modifying a DataFrame's Row Index
A DataFrame's row index can be changed using the __set_index()__ method
- Use __inplace=True__ in the method call to modify the original DataFrame
- The new index can be
    - One or more existing columns (provide the list of names)
    - One or more arrays, serving as the new index (less common)
- The new index can replace the existing one or expand it
- The ability to modify the DataFrame's index enables more interesting label-based indexing of the rows

use the __marital__ column as the __DataFrame__'s row index (instead of the default __RangeIndex__)


```python
df_new_idx = df.set_index("marital")
df_new_idx.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>30</td>
      <td>unemployed</td>
      <td>primary</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>married</th>
      <td>33</td>
      <td>services</td>
      <td>secondary</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <td>35</td>
      <td>management</td>
      <td>tertiary</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



the new index can be used to filter more easily on marital status


```python
df_new_idx.loc["single"].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>single</th>
      <td>35</td>
      <td>management</td>
      <td>tertiary</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <td>35</td>
      <td>management</td>
      <td>tertiary</td>
      <td>no</td>
      <td>747</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>23</td>
      <td>feb</td>
      <td>141</td>
      <td>2</td>
      <td>176</td>
      <td>3</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <td>20</td>
      <td>student</td>
      <td>secondary</td>
      <td>no</td>
      <td>502</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>30</td>
      <td>apr</td>
      <td>261</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>yes</td>
    </tr>
    <tr>
      <th>single</th>
      <td>37</td>
      <td>admin.</td>
      <td>tertiary</td>
      <td>no</td>
      <td>2317</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>20</td>
      <td>apr</td>
      <td>114</td>
      <td>1</td>
      <td>152</td>
      <td>2</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <td>25</td>
      <td>blue-collar</td>
      <td>primary</td>
      <td>no</td>
      <td>-221</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>23</td>
      <td>may</td>
      <td>250</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



Multiple columns can be used as the (multi-level) row index


```python
df_new_idx = df.set_index(["marital", "education"])
df_new_idx.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
    <tr>
      <th>marital</th>
      <th>education</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">married</th>
      <th>primary</th>
      <td>30</td>
      <td>unemployed</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>secondary</th>
      <td>33</td>
      <td>services</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <th>tertiary</th>
      <td>35</td>
      <td>management</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">married</th>
      <th>tertiary</th>
      <td>30</td>
      <td>management</td>
      <td>no</td>
      <td>1476</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>secondary</th>
      <td>59</td>
      <td>blue-collar</td>
      <td>no</td>
      <td>0</td>
      <td>yes</td>
      <td>no</td>
      <td>unknown</td>
      <td>5</td>
      <td>may</td>
      <td>226</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



## Hierarchical Indexing (MultiIndex)
A pandas DataFrame or Series can have a multi-level (hierarchical) index


```python
marital_housing_counts = df[["marital", "housing"]].value_counts()
marital_housing_counts
```




    marital   housing
    married   yes        1625
              no         1172
    single    yes         636
              no          560
    divorced  yes         298
              no          230
    dtype: int64



check the index


```python
marital_housing_counts.index
```




    MultiIndex([( 'married', 'yes'),
                ( 'married',  'no'),
                (  'single', 'yes'),
                (  'single',  'no'),
                ('divorced', 'yes'),
                ('divorced',  'no')],
               names=['marital', 'housing'])



label-based indexing on the 1st level


```python
marital_housing_counts["married"]
```




    housing
    yes    1625
    no     1172
    dtype: int64



hierachical label-based indexing on the 2 levels


```python
marital_housing_counts["married"]["yes"]
```




    1625



## Resetting a DataFrame's Index
You can reset the DataFrame's index to the default one by using the __reset_index()__ method
- By default, pandas will re-insert the index as columns in the dataset (use __drop=True__ in the method call to drop it instead)
- Use __inplace=True__ in the method call to modify the original DataFrame directly
- For a __MultiIndex__, you can select which levels to reset (level parameter)


```python
df_new_idx = df.set_index(["marital", "education"])
df_new_idx.head(4)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
    <tr>
      <th>marital</th>
      <th>education</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">married</th>
      <th>primary</th>
      <td>30</td>
      <td>unemployed</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>secondary</th>
      <td>33</td>
      <td>services</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <th>tertiary</th>
      <td>35</td>
      <td>management</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>married</th>
      <th>tertiary</th>
      <td>30</td>
      <td>management</td>
      <td>no</td>
      <td>1476</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



reset the whole indexed


```python
df_new_idx.reset_index().head(4)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>education</th>
      <th>age</th>
      <th>job</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>primary</td>
      <td>30</td>
      <td>unemployed</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>1</th>
      <td>married</td>
      <td>secondary</td>
      <td>33</td>
      <td>services</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>2</th>
      <td>single</td>
      <td>tertiary</td>
      <td>35</td>
      <td>management</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>3</th>
      <td>married</td>
      <td>tertiary</td>
      <td>30</td>
      <td>management</td>
      <td>no</td>
      <td>1476</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



only reset the education (2nd) level


```python
df_new_idx.reset_index(level="education").head(4)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>education</th>
      <th>age</th>
      <th>job</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>primary</td>
      <td>30</td>
      <td>unemployed</td>
      <td>no</td>
      <td>1787</td>
      <td>no</td>
      <td>no</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
    <tr>
      <th>married</th>
      <td>secondary</td>
      <td>33</td>
      <td>services</td>
      <td>no</td>
      <td>4789</td>
      <td>yes</td>
      <td>yes</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>single</th>
      <td>tertiary</td>
      <td>35</td>
      <td>management</td>
      <td>no</td>
      <td>1350</td>
      <td>yes</td>
      <td>no</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>no</td>
    </tr>
    <tr>
      <th>married</th>
      <td>tertiary</td>
      <td>30</td>
      <td>management</td>
      <td>no</td>
      <td>1476</td>
      <td>yes</td>
      <td>yes</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>no</td>
    </tr>
  </tbody>
</table>
</div>



----------------- 

# Working with Variables

## Data Cleaning
- Toy data sets are clean and tidy
- Real data sets are messy and dirty
    -Duplicates
    - Missing values
        - e.g., a sensor was offline or broken, a person didn't answer a question in a survey, ...
    - Outliers
        - e.g., extreme amounts, ...
    - Value errors
        - e.g., negative ages, birthdates in the future, ...
    - Inconsistent category encoding and spelling mistakes
        - e.g., "unemployed", "Unemployed", "Unemployd", ...
    - Inconsistent formats
        - e.g., 2020-11-19, 2020/11/12, 2020-19-11, ...
- If nothing is done → garbage in, garbage out!!!

## Deduplicating Data
- Use the __duplicated()__ method to identify duplicated rows in a DataFrame (or values in a Series)
- Use __drop_duplicates()__ to remove duplicates from a DataFrame or Series
    - Use __inplace=True__ to modify the original DataFrame or Series
    - Use the __subset argument__ to limit the columns on which to search for duplicates
    - Use the __keep argument__ to indicate what item of the duplicates must be retained (first, last, drop all duplicates)


```python
df_persons = pd.read_csv("persons.csv")
df_persons
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>Trevor</td>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Will</td>
      <td>Snow</td>
      <td>Unknown</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sarah</td>
      <td>Sanders</td>
      <td>20</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>James</td>
      <td>Steward</td>
      <td>45</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Will</td>
      <td>Tylor</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_persons.drop_duplicates()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>Trevor</td>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Will</td>
      <td>Snow</td>
      <td>Unknown</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sarah</td>
      <td>Sanders</td>
      <td>20</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>James</td>
      <td>Steward</td>
      <td>45</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Will</td>
      <td>Tylor</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



## Dealing with Missing Values
Two main strategies for dealing with missing values
- __Remove rows (or columns)__ with missing values → viable when the data set is big (or if impacted columns are not important)
- __Replace the missing values__
    - Using basic strategies (e.g., replace with a constant, replace with the column's median, ...)
    - Using advanced strategies (e.g., ML algorithms that infer missing values based on values of other columns)
                              
/!\ The presence of missing values can have serious repercussions on the column data types!

age typed as a string (due to the "Unknown"), children typed as float due to NaN


```python
df_persons.dtypes
```




    first        object
    last         object
    age          object
    children    float64
    dtype: object



## Dropping Missing Values
Use the __dropna()__ method to remove rows (or columns) with missing values
Important arguments
- __axis__: axis along which missing values will be removed
- __how__: whether to remove a row or column if all values are missing (__"all"__) or if any value is missing (__"any"__)
- __subset__: labels on other axis to consider when looking for missing values
- __inplace__: if __True__, do the operation on the original object

drop rows with missiong values on any of the columns


```python
df_persons.dropna().head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sarah</td>
      <td>Sanders</td>
      <td>20</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Will</td>
      <td>Tylor</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



drop rows with missiong values on either first or age columns (or both)


```python
df_persons.dropna(subset=["first", "age"]).head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Will</td>
      <td>Snow</td>
      <td>Unknown</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sarah</td>
      <td>Sanders</td>
      <td>20</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>James</td>
      <td>Steward</td>
      <td>45</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Will</td>
      <td>Tylor</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



drop rows with missing values on both first & age columns


```python
df_persons.dropna(subset=["first", "age"], how="all").head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Will</td>
      <td>Snow</td>
      <td>Unknown</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Sarah</td>
      <td>Sanders</td>
      <td>20</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>James</td>
      <td>Steward</td>
      <td>45</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Will</td>
      <td>Tylor</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>



## Replacing Missing Values
Use the __fillna()__ method to replace missing values in a DataFrame
Important arguments
- __value__: replacement value
- __axis__: axis along which to fill missing values
- __inplace__: if __True__, do the operation on the original DataFrame

fill missing values with the (constant) value -999


```python
df_persons.fillna(-999).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>last</th>
      <th>age</th>
      <th>children</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>John</td>
      <td>Doe</td>
      <td>24</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jane</td>
      <td>Doe</td>
      <td>21</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-999</td>
      <td>Trevor</td>
      <td>-999</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Undefined</td>
      <td>Smith</td>
      <td>34</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Will</td>
      <td>Snow</td>
      <td>Unknown</td>
      <td>-999.0</td>
    </tr>
  </tbody>
</table>
</div>



## Recasting Variables
- Variables should be typed with the most appropriate data type
    - Binary variables should be encoded as booleans or __0__, __1__
    - Discrete quantitative variables should be encoded as integers
    - Depending on the intended goal, categorical features can be dummy-encoded
    - etc.
- Use the __convert_dtypes()__ method to let pandas attempt to infer the most appropriate data types for a data frame's columns
- Use the __astype()__ method to recast columns (__Series__) to other types  

/!\ The most appropriate data type is often task-dependant!

orginal data types in the bank data frame


```python
df.dtypes
```




    age           int64
    job          object
    marital      object
    education    object
    default      object
    balance       int64
    housing      object
    loan         object
    contact      object
    day           int64
    month        object
    duration      int64
    campaign      int64
    pdays         int64
    previous      int64
    poutcome     object
    y            object
    dtype: object



data types after using the convert_dtypes() method


```python
df_converted = df.convert_dtypes()
df_converted.dtypes
```




    age           Int64
    job          string
    marital      string
    education    string
    default      string
    balance       Int64
    housing      string
    loan         string
    contact      string
    day           Int64
    month        string
    duration      Int64
    campaign      Int64
    pdays         Int64
    previous      Int64
    poutcome     string
    y            string
    dtype: object



Converting binary (yes/no) variables to 0, 1


```python
for col in ["default", "housing", "loan", "y"]:
    df[col] = (df[col] == "yes").astype(int)
    
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>1787</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>4789</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>35</td>
      <td>management</td>
      <td>single</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1350</td>
      <td>1</td>
      <td>0</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30</td>
      <td>management</td>
      <td>married</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1476</td>
      <td>1</td>
      <td>1</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>59</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>5</td>
      <td>may</td>
      <td>226</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



Recasting categorical variables from strings to pandas' __CategoricalDtype__


```python
for col in ["job", "marital", "contact", "month", "poutcome"]:
    col_type = pd.CategoricalDtype(df[col].drop_duplicates())
    df[col] = df[col].astype(col_type)
    
edu_type = pd.CategoricalDtype(
    categories=["primary", "secondary", "tertiary", "unknown"],
    ordered=True
)
df["education"] = df["education"].astype(edu_type)
df.dtypes
```




    age             int64
    job          category
    marital      category
    education    category
    default         int32
    balance         int64
    housing         int32
    loan            int32
    contact      category
    day             int64
    month        category
    duration        int64
    campaign        int64
    pdays           int64
    previous        int64
    poutcome     category
    y               int32
    dtype: object



Sorting on *education* respects the category order now
 
(i) In practice, categorical variables are often left as strings and not encoded as __CategoricalDtype__.


```python
df.sort_values(by="education")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>1787</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1984</th>
      <td>56</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>551</td>
      <td>0</td>
      <td>0</td>
      <td>unknown</td>
      <td>29</td>
      <td>may</td>
      <td>27</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>992</th>
      <td>39</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>879</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>26</td>
      <td>may</td>
      <td>102</td>
      <td>2</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>994</th>
      <td>59</td>
      <td>housemaid</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>27</td>
      <td>aug</td>
      <td>76</td>
      <td>11</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3255</th>
      <td>55</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>284</td>
      <td>0</td>
      <td>1</td>
      <td>telephone</td>
      <td>14</td>
      <td>jul</td>
      <td>252</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>150</th>
      <td>41</td>
      <td>entrepreneur</td>
      <td>married</td>
      <td>unknown</td>
      <td>0</td>
      <td>89</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>6</td>
      <td>may</td>
      <td>333</td>
      <td>2</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>149</th>
      <td>37</td>
      <td>technician</td>
      <td>single</td>
      <td>unknown</td>
      <td>0</td>
      <td>391</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>8</td>
      <td>may</td>
      <td>103</td>
      <td>3</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4337</th>
      <td>73</td>
      <td>retired</td>
      <td>married</td>
      <td>unknown</td>
      <td>0</td>
      <td>519</td>
      <td>0</td>
      <td>0</td>
      <td>telephone</td>
      <td>16</td>
      <td>oct</td>
      <td>434</td>
      <td>1</td>
      <td>57</td>
      <td>1</td>
      <td>failure</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4342</th>
      <td>50</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>unknown</td>
      <td>0</td>
      <td>2284</td>
      <td>1</td>
      <td>0</td>
      <td>telephone</td>
      <td>31</td>
      <td>jul</td>
      <td>1088</td>
      <td>17</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1069</th>
      <td>45</td>
      <td>technician</td>
      <td>single</td>
      <td>unknown</td>
      <td>0</td>
      <td>7108</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>18</td>
      <td>nov</td>
      <td>53</td>
      <td>1</td>
      <td>172</td>
      <td>3</td>
      <td>failure</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>4521 rows × 17 columns</p>
</div>



## Creating New Features
- Data analyses and machine learning often involve feature engineering, i.e., creating new features from existing ones based on domain knowledge (and intuition)
- Examples of feature engineering
    - Extracting day of week, month, year, etc. from datetime variables
    - Reverse geocoding (i.e., creating country, state, department, etc. fields from geographical coordinates)
    - Binning
    - One-hot encoding
    - Log-transformation
    - etc.

new column with the count of the customer's loans


```python
df["loan_count"] = df["loan"] + df["housing"] 
```

is account balance greater than average balance?


```python
df["richer_than_avg"] = (df["balance"] > df["balance"].mean()).astype(int)
```

is the customer a senior citizen?


```python
df["senior"] = (df["age"] > 60).astype(int)
```

is the customer a young adult?


```python
df["senior"] = (df["age"] <= 25).astype(int)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
      <th>loan_count</th>
      <th>richer_than_avg</th>
      <th>senior</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>1787</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>4789</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>35</td>
      <td>management</td>
      <td>single</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1350</td>
      <td>1</td>
      <td>0</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30</td>
      <td>management</td>
      <td>married</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1476</td>
      <td>1</td>
      <td>1</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>59</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>5</td>
      <td>may</td>
      <td>226</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>4516</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>-333</td>
      <td>1</td>
      <td>0</td>
      <td>cellular</td>
      <td>30</td>
      <td>jul</td>
      <td>329</td>
      <td>5</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4517</th>
      <td>57</td>
      <td>self-employed</td>
      <td>married</td>
      <td>tertiary</td>
      <td>1</td>
      <td>-3313</td>
      <td>1</td>
      <td>1</td>
      <td>unknown</td>
      <td>9</td>
      <td>may</td>
      <td>153</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4518</th>
      <td>57</td>
      <td>technician</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>295</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>aug</td>
      <td>151</td>
      <td>11</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4519</th>
      <td>28</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>1137</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>6</td>
      <td>feb</td>
      <td>129</td>
      <td>4</td>
      <td>211</td>
      <td>3</td>
      <td>other</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4520</th>
      <td>44</td>
      <td>entrepreneur</td>
      <td>single</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1136</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>3</td>
      <td>apr</td>
      <td>345</td>
      <td>2</td>
      <td>249</td>
      <td>7</td>
      <td>other</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>4521 rows × 20 columns</p>
</div>



## One-Hot Encoding
- Machine learning tasks often require one-hot encoding of categorical variables
    - The variable is transformed into multiple columns
    - Each column represents a category of the variable
    - A __1__ on a column indicates which category the original variable had
    - All the other categories' columns contain __0__
- Use the __get_dummies()__ function to one-hot encode categorical columns

Dummy encode the education variable, join the dummy variables to the data frame (more on joins later), and drop the original column


```python
df.join(pd.get_dummies(df["education"], prefix="education")).drop("education", axis=1)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>job</th>
      <th>marital</th>
      <th>education</th>
      <th>default</th>
      <th>balance</th>
      <th>housing</th>
      <th>loan</th>
      <th>contact</th>
      <th>day</th>
      <th>month</th>
      <th>duration</th>
      <th>campaign</th>
      <th>pdays</th>
      <th>previous</th>
      <th>poutcome</th>
      <th>y</th>
      <th>loan_count</th>
      <th>richer_than_avg</th>
      <th>senior</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>30</td>
      <td>unemployed</td>
      <td>married</td>
      <td>primary</td>
      <td>0</td>
      <td>1787</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>oct</td>
      <td>79</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>4789</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>11</td>
      <td>may</td>
      <td>220</td>
      <td>1</td>
      <td>339</td>
      <td>4</td>
      <td>failure</td>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>35</td>
      <td>management</td>
      <td>single</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1350</td>
      <td>1</td>
      <td>0</td>
      <td>cellular</td>
      <td>16</td>
      <td>apr</td>
      <td>185</td>
      <td>1</td>
      <td>330</td>
      <td>1</td>
      <td>failure</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30</td>
      <td>management</td>
      <td>married</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1476</td>
      <td>1</td>
      <td>1</td>
      <td>unknown</td>
      <td>3</td>
      <td>jun</td>
      <td>199</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>59</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>unknown</td>
      <td>5</td>
      <td>may</td>
      <td>226</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>4516</th>
      <td>33</td>
      <td>services</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>-333</td>
      <td>1</td>
      <td>0</td>
      <td>cellular</td>
      <td>30</td>
      <td>jul</td>
      <td>329</td>
      <td>5</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4517</th>
      <td>57</td>
      <td>self-employed</td>
      <td>married</td>
      <td>tertiary</td>
      <td>1</td>
      <td>-3313</td>
      <td>1</td>
      <td>1</td>
      <td>unknown</td>
      <td>9</td>
      <td>may</td>
      <td>153</td>
      <td>1</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4518</th>
      <td>57</td>
      <td>technician</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>295</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>19</td>
      <td>aug</td>
      <td>151</td>
      <td>11</td>
      <td>-1</td>
      <td>0</td>
      <td>unknown</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4519</th>
      <td>28</td>
      <td>blue-collar</td>
      <td>married</td>
      <td>secondary</td>
      <td>0</td>
      <td>1137</td>
      <td>0</td>
      <td>0</td>
      <td>cellular</td>
      <td>6</td>
      <td>feb</td>
      <td>129</td>
      <td>4</td>
      <td>211</td>
      <td>3</td>
      <td>other</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4520</th>
      <td>44</td>
      <td>entrepreneur</td>
      <td>single</td>
      <td>tertiary</td>
      <td>0</td>
      <td>1136</td>
      <td>1</td>
      <td>1</td>
      <td>cellular</td>
      <td>3</td>
      <td>apr</td>
      <td>345</td>
      <td>2</td>
      <td>249</td>
      <td>7</td>
      <td>other</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>4521 rows × 20 columns</p>
</div>



## Grouping and Aggregating Data

## Group By
Group by refers to a 3-step process
1. Splitting the data into groups based on some criteria (e.g., by marital status)
2. Applying a function to each group separately
    - Aggregation (e.g., computing summary statistics)
    - Transformation (e.g., standardization, NA filling, ...)
    - Filtering (e.g., remove groups with few rows or based on group aggregates, ...)
3. Combining the results into a data structure (a DataFrame most of the time)

(i) If this sounds familiar to you, it is because this is how __value_counts()__ works.

![title](/images/2022-04-30-pandas/02.group_by.png)   

(i) Refer to [the documentation](https://pandas.pydata.org/pandas-docs/stable/reference/groupby.html) for details on __DataFrameGroupBy__ objects and possible aggregations and transformations.

Example: group by marital status and calculate the min, median, and max balance as well as the median age for each group


```python
df.groupby("marital").aggregate(
    # aggregate based on a dict of col_name : 
    # aggregates_list 
    {"balance" : ["min", "median", "max"],
    "age": "median"}
)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">balance</th>
      <th>age</th>
    </tr>
    <tr>
      <th></th>
      <th>min</th>
      <th>median</th>
      <th>max</th>
      <th>median</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>-3313</td>
      <td>452.0</td>
      <td>71188</td>
      <td>42</td>
    </tr>
    <tr>
      <th>single</th>
      <td>-1313</td>
      <td>462.0</td>
      <td>27733</td>
      <td>32</td>
    </tr>
    <tr>
      <th>divorced</th>
      <td>-1148</td>
      <td>367.5</td>
      <td>26306</td>
      <td>45</td>
    </tr>
  </tbody>
</table>
</div>



Example: group by marital status and education level, then calculate median balance, age mean and standard deviation, and number of rows in each group


```python
df.groupby(["marital", "education"]).aggregate(
    # aggregate based on kwarg = (column, aggregate) 
    balance_median = ("balance", "median"),
    age_mean = ("age", "mean"),
    age_std = ("age", "std"),
    count = ("marital", "count")
).reset_index()
# reset idx to more marital & ducation back as cols
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>education</th>
      <th>balance_median</th>
      <th>age_mean</th>
      <th>age_std</th>
      <th>count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>primary</td>
      <td>400.5</td>
      <td>47.511407</td>
      <td>10.594826</td>
      <td>526</td>
    </tr>
    <tr>
      <th>1</th>
      <td>married</td>
      <td>secondary</td>
      <td>406.0</td>
      <td>42.404345</td>
      <td>10.113719</td>
      <td>1427</td>
    </tr>
    <tr>
      <th>2</th>
      <td>married</td>
      <td>tertiary</td>
      <td>593.0</td>
      <td>41.777166</td>
      <td>9.574839</td>
      <td>727</td>
    </tr>
    <tr>
      <th>3</th>
      <td>married</td>
      <td>unknown</td>
      <td>559.0</td>
      <td>48.444444</td>
      <td>9.587568</td>
      <td>117</td>
    </tr>
    <tr>
      <th>4</th>
      <td>single</td>
      <td>primary</td>
      <td>538.0</td>
      <td>37.013699</td>
      <td>9.888957</td>
      <td>73</td>
    </tr>
    <tr>
      <th>5</th>
      <td>single</td>
      <td>secondary</td>
      <td>376.0</td>
      <td>33.052545</td>
      <td>7.120707</td>
      <td>609</td>
    </tr>
    <tr>
      <th>6</th>
      <td>single</td>
      <td>tertiary</td>
      <td>613.5</td>
      <td>34.512821</td>
      <td>7.217769</td>
      <td>468</td>
    </tr>
    <tr>
      <th>7</th>
      <td>single</td>
      <td>unknown</td>
      <td>526.5</td>
      <td>34.652174</td>
      <td>9.175371</td>
      <td>46</td>
    </tr>
    <tr>
      <th>8</th>
      <td>divorced</td>
      <td>primary</td>
      <td>328.0</td>
      <td>51.392405</td>
      <td>11.339083</td>
      <td>79</td>
    </tr>
    <tr>
      <th>9</th>
      <td>divorced</td>
      <td>secondary</td>
      <td>319.5</td>
      <td>43.496296</td>
      <td>9.333056</td>
      <td>270</td>
    </tr>
    <tr>
      <th>10</th>
      <td>divorced</td>
      <td>tertiary</td>
      <td>442.0</td>
      <td>45.148387</td>
      <td>9.340454</td>
      <td>155</td>
    </tr>
    <tr>
      <th>11</th>
      <td>divorced</td>
      <td>unknown</td>
      <td>774.0</td>
      <td>50.375000</td>
      <td>10.672242</td>
      <td>24</td>
    </tr>
  </tbody>
</table>
</div>



-------------------------  
# Reshaping Dataframes

## Pivoting
Pivoting is useful when studying how a given (numeric) variable is conditioned by two or more (discrete) variables  
    - The conditioning variables' values are used as dimensions (row and column indexes)  
    - The cells contain the values of the conditioned variable for the corresponding dimensions
    
![title](/images/2022-04-30-pandas/03.pivoting.png)   


```python
df_aggs = df.groupby(["marital", "education"]).aggregate(
    balance_median = ("balance", "median")
).reset_index()
df_aggs
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>education</th>
      <th>balance_median</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>primary</td>
      <td>400.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>married</td>
      <td>secondary</td>
      <td>406.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>married</td>
      <td>tertiary</td>
      <td>593.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>married</td>
      <td>unknown</td>
      <td>559.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>single</td>
      <td>primary</td>
      <td>538.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>single</td>
      <td>secondary</td>
      <td>376.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>single</td>
      <td>tertiary</td>
      <td>613.5</td>
    </tr>
    <tr>
      <th>7</th>
      <td>single</td>
      <td>unknown</td>
      <td>526.5</td>
    </tr>
    <tr>
      <th>8</th>
      <td>divorced</td>
      <td>primary</td>
      <td>328.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>divorced</td>
      <td>secondary</td>
      <td>319.5</td>
    </tr>
    <tr>
      <th>10</th>
      <td>divorced</td>
      <td>tertiary</td>
      <td>442.0</td>
    </tr>
    <tr>
      <th>11</th>
      <td>divorced</td>
      <td>unknown</td>
      <td>774.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_aggs_pivoted = df_aggs.pivot(
    index="marital", columns="education", values="balance_median"
)
df_aggs_pivoted
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>education</th>
      <th>primary</th>
      <th>secondary</th>
      <th>tertiary</th>
      <th>unknown</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>400.5</td>
      <td>406.0</td>
      <td>593.0</td>
      <td>559.0</td>
    </tr>
    <tr>
      <th>single</th>
      <td>538.0</td>
      <td>376.0</td>
      <td>613.5</td>
      <td>526.5</td>
    </tr>
    <tr>
      <th>divorced</th>
      <td>328.0</td>
      <td>319.5</td>
      <td>442.0</td>
      <td>774.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
responses_per_marital = df.groupby(["marital", "y"]).aggregate(
    count = ("y", "count")
).reset_index()
responses_per_marital
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>y</th>
      <th>count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>0</td>
      <td>2520</td>
    </tr>
    <tr>
      <th>1</th>
      <td>married</td>
      <td>1</td>
      <td>277</td>
    </tr>
    <tr>
      <th>2</th>
      <td>single</td>
      <td>0</td>
      <td>1029</td>
    </tr>
    <tr>
      <th>3</th>
      <td>single</td>
      <td>1</td>
      <td>167</td>
    </tr>
    <tr>
      <th>4</th>
      <td>divorced</td>
      <td>0</td>
      <td>451</td>
    </tr>
    <tr>
      <th>5</th>
      <td>divorced</td>
      <td>1</td>
      <td>77</td>
    </tr>
  </tbody>
</table>
</div>




```python
responses_pivoted = responses_per_marital.pivot(index="marital", columns="y", values="count")
responses_pivoted
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>y</th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>2520</td>
      <td>277</td>
    </tr>
    <tr>
      <th>single</th>
      <td>1029</td>
      <td>167</td>
    </tr>
    <tr>
      <th>divorced</th>
      <td>451</td>
      <td>77</td>
    </tr>
  </tbody>
</table>
</div>




```python
response_pct = 100 * responses_pivoted.divide(responses_pivoted.sum(axis="columns"), axis="index")
response_pct
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>y</th>
      <th>0</th>
      <th>1</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>90.096532</td>
      <td>9.903468</td>
    </tr>
    <tr>
      <th>single</th>
      <td>86.036789</td>
      <td>13.963211</td>
    </tr>
    <tr>
      <th>divorced</th>
      <td>85.416667</td>
      <td>14.583333</td>
    </tr>
  </tbody>
</table>
</div>



## Melting
Melting can be seen as the inverse of pivoting
![title](/images/2022-04-30-pandas/04.meting.png)   



```python
df_aggs_pivoted
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>education</th>
      <th>primary</th>
      <th>secondary</th>
      <th>tertiary</th>
      <th>unknown</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>married</th>
      <td>400.5</td>
      <td>406.0</td>
      <td>593.0</td>
      <td>559.0</td>
    </tr>
    <tr>
      <th>single</th>
      <td>538.0</td>
      <td>376.0</td>
      <td>613.5</td>
      <td>526.5</td>
    </tr>
    <tr>
      <th>divorced</th>
      <td>328.0</td>
      <td>319.5</td>
      <td>442.0</td>
      <td>774.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_aggs_pivoted.dtypes
```




    education
    primary      float64
    secondary    float64
    tertiary     float64
    unknown      float64
    dtype: object




```python
# DOESN'T WORK !!!

#df_aggs_pivoted.reset_index().melt(id_vars="marital", value_name="balance_median")
```


```python
df_aggs_pivoted.convert_dtypes().reset_index().melt(id_vars="marital", value_name="balance_median")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>marital</th>
      <th>variable</th>
      <th>balance_median</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>married</td>
      <td>primary</td>
      <td>400.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>single</td>
      <td>primary</td>
      <td>538.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>divorced</td>
      <td>primary</td>
      <td>328.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>married</td>
      <td>secondary</td>
      <td>406.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>single</td>
      <td>secondary</td>
      <td>376.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>divorced</td>
      <td>secondary</td>
      <td>319.5</td>
    </tr>
    <tr>
      <th>6</th>
      <td>married</td>
      <td>tertiary</td>
      <td>593.0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>single</td>
      <td>tertiary</td>
      <td>613.5</td>
    </tr>
    <tr>
      <th>8</th>
      <td>divorced</td>
      <td>tertiary</td>
      <td>442.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>married</td>
      <td>unknown</td>
      <td>559.0</td>
    </tr>
    <tr>
      <th>10</th>
      <td>single</td>
      <td>unknown</td>
      <td>526.5</td>
    </tr>
    <tr>
      <th>11</th>
      <td>divorced</td>
      <td>unknown</td>
      <td>774.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
# df_aggs_pivoted.reset_index().melt(id_vars="marital", value_name="balance_median")
# without .convert_dtypes() is doesn't work  
# this could be related to the fact that pandas converts your string columns 
# to categorical columns, which raises an error, if you tries to set a value in a row to 
# a value that is not in the allowed categories (because it was not previously observed).

# A simple fix could be to force all your columns to be string columns instead of pandas-categorical ones, like:

for col in ['Provincia', 'Consumo', 'Potencia max', 'Comercializadora_encoded']:
   df_copy[col] = df_copy[col].astype(str)
```

## Cross Tabulations
Use the __crosstab()__ function to compute cross tabulations (i.e., co-occurrence counts) of two or more categorical Series
- Can be normalized on rows, columns, etc. using __the normalize argument__
- Can be marginalized by passing __margins=True__ in the function call


```python
# normalize on rows -> yes/no percentage
# in each category of married

# margins=True : sum on columns -> 
# yes/no percentage in all the data frame

100 * pd.crosstab(df["marital"], df["y"],
                 normalize="index",
                 margins=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>y</th>
      <th>no</th>
      <th>yes</th>
    </tr>
    <tr>
      <th>marital</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>divorced</th>
      <td>85.416667</td>
      <td>14.583333</td>
    </tr>
    <tr>
      <th>married</th>
      <td>90.096532</td>
      <td>9.903468</td>
    </tr>
    <tr>
      <th>single</th>
      <td>86.036789</td>
      <td>13.963211</td>
    </tr>
    <tr>
      <th>All</th>
      <td>88.476001</td>
      <td>11.523999</td>
    </tr>
  </tbody>
</table>
</div>



## Other Reshaping Operations
[Other reshaping operations](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) include
- Stacking and unstacking
- Pivot tables (generalization of the simple pivot)
- Exploding list-like columns
- etc.

----------------------------  
# Working with Multiple Tables

- Real data sets are often organized in multiple data tables
- Each table describes one entity type
    - e.g., a table describes customers, another table describes products, and a third table describes purchases
- Entities can reference other entities they are related to
- In order to conduct your analysis, you need to “patch” these tables together

![title](/images/2022-04-30-pandas/05.multiple_tables.png)   


```python
customers = pd.read_csv("retail/customers.csv")
customers.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Diana Prince</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Bruce Wayne</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Peter Parker</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
    </tr>
  </tbody>
</table>
</div>




```python
purchases = pd.read_csv("retail/purchases.csv")
purchases.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>product_id</th>
      <th>purchase_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>1</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>4</td>
      <td>2012-12-20</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>2</td>
      <td>2019-07-05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>2</td>
      <td>2019-11-24</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7</td>
      <td>2</td>
      <td>2020-01-24</td>
    </tr>
  </tbody>
</table>
</div>




```python
products = pd.read_csv("retail/products.csv")
products.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>product_name</th>
      <th>release_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>PlayStation 4</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Nintendo Switch</td>
      <td>2017-03-03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>XBox One X</td>
      <td>2017-11-07</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Nintendo Wii U</td>
      <td>2012-11-18</td>
    </tr>
  </tbody>
</table>
</div>



## Merging Data Frames
- Use the __merge()__ method to merge a DataFrame with another DataFrame (or Series)
- The merge is __done with a database-style (SQL) join__
- Usually based on one or more common columns (e.g., the customer_id column in both customers and purchases)
    - If a row from the left object and a row from the right object have matching values for the join columns → a row combining the two is produced
    - If no match is found → output depends on the join type
        - Inner join → no row is produced
        - Left join → for left rows with no match, produce a row (with NA filled right row)
        - Right join → for right rows with no match, produce a row (with NA filled left row)
        - Outer join → combination of left and right join
- Joins can also be performed on rows (less common)

Inner Join


```python
customers.merge(purchases, on="customer_id")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
      <th>product_id</th>
      <th>purchase_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>1</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>2</td>
      <td>2019-11-24</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Diana Prince</td>
      <td>2</td>
      <td>2019-07-05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
      <td>4</td>
      <td>2012-12-20</td>
    </tr>
  </tbody>
</table>
</div>



Left join


```python
customers.merge(purchases, on="customer_id", how="left")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
      <th>product_id</th>
      <th>purchase_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>1.0</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>2.0</td>
      <td>2019-11-24</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Diana Prince</td>
      <td>2.0</td>
      <td>2019-07-05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>Bruce Wayne</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>Peter Parker</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
      <td>4.0</td>
      <td>2012-12-20</td>
    </tr>
  </tbody>
</table>
</div>



Right join


```python
customers.merge(purchases, on="customer_id", how="right")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
      <th>product_id</th>
      <th>purchase_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>1</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
      <td>4</td>
      <td>2012-12-20</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Diana Prince</td>
      <td>2</td>
      <td>2019-07-05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>2</td>
      <td>2019-11-24</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7</td>
      <td>NaN</td>
      <td>2</td>
      <td>2020-01-24</td>
    </tr>
  </tbody>
</table>
</div>



Outer join


```python
customers.merge(purchases, on="customer_id", how="outer")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
      <th>product_id</th>
      <th>purchase_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>1.0</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>2.0</td>
      <td>2019-11-24</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Diana Prince</td>
      <td>2.0</td>
      <td>2019-07-05</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>Bruce Wayne</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>Peter Parker</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
      <td>4.0</td>
      <td>2012-12-20</td>
    </tr>
    <tr>
      <th>6</th>
      <td>7</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>2020-01-24</td>
    </tr>
  </tbody>
</table>
</div>



- Multiple tables can be merged together (consecutively)
- Sometimes, the merge is on columns that do not have the same names (e.g., the __id__ column in products and the __product_id__ column in purchases)
    - Use the __left_on__ and __right_on__ arguments to specify the column names in the left and right data frames respectively


```python
customers.merge(
    # if the merge is on columns that have the
    # same name -> the on arg is optional
    purchases,
).merge(
    products,
    # name of column on left side
    left_on="product_id",
    # name of column on right side
    right_on="id"
).drop("id", axis="columns")
# drop the duplicated column
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>customer_name</th>
      <th>product_id</th>
      <th>purchase_date</th>
      <th>product_name</th>
      <th>release_date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>1</td>
      <td>2013-11-15</td>
      <td>PlayStation 4</td>
      <td>2013-11-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>Clark Kent</td>
      <td>2</td>
      <td>2019-11-24</td>
      <td>Nintendo Switch</td>
      <td>2017-03-03</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>Diana Prince</td>
      <td>2</td>
      <td>2019-07-05</td>
      <td>Nintendo Switch</td>
      <td>2017-03-03</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5</td>
      <td>Natasha Romanoff</td>
      <td>4</td>
      <td>2012-12-20</td>
      <td>Nintendo Wii U</td>
      <td>2012-11-18</td>
    </tr>
  </tbody>
</table>
</div>



# Other tips & tricks

[Configure Options & Settings at Interpreter Startup](https://realpython.com/python-pandas-tricks/#1-configure-boptions-settings-at-interpreter-startup)

Highlight all negative values in a dataframe


```python
def color_negative_red(val):
    color = 'red' if val < 0 else 'black'
    return 'color: %s' % color


df = pd.DataFrame(dict(col_1=[1.53,-2.5,3.53], 
                       col_2=[-4.1,5.9,0])
                 )
df.style.applymap(color_negative_red)
```




<style type="text/css">
#T_97f30_row0_col0, #T_97f30_row1_col1, #T_97f30_row2_col0, #T_97f30_row2_col1 {
  color: black;
}
#T_97f30_row0_col1, #T_97f30_row1_col0 {
  color: red;
}
</style>
<table id="T_97f30_">
  <thead>
    <tr>
      <th class="blank level0" >&nbsp;</th>
      <th class="col_heading level0 col0" >col_1</th>
      <th class="col_heading level0 col1" >col_2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th id="T_97f30_level0_row0" class="row_heading level0 row0" >0</th>
      <td id="T_97f30_row0_col0" class="data row0 col0" >1.530000</td>
      <td id="T_97f30_row0_col1" class="data row0 col1" >-4.100000</td>
    </tr>
    <tr>
      <th id="T_97f30_level0_row1" class="row_heading level0 row1" >1</th>
      <td id="T_97f30_row1_col0" class="data row1 col0" >-2.500000</td>
      <td id="T_97f30_row1_col1" class="data row1 col1" >5.900000</td>
    </tr>
    <tr>
      <th id="T_97f30_level0_row2" class="row_heading level0 row2" >2</th>
      <td id="T_97f30_row2_col0" class="data row2 col0" >3.530000</td>
      <td id="T_97f30_row2_col1" class="data row2 col1" >0.000000</td>
    </tr>
  </tbody>
</table>




Pandas options


```python
pd.options.display.max_columns = 50  # None -> No Restrictions  
pd.options.display.max_rows = 200    # None -> Be careful with this   
pd.options.display.max_colwidth = 100  
pd.options.display.precision = 3  
```

Add row total and column total to a numerical dataframe


```python
df = pd.DataFrame(dict(A=[2,6,3],
                       B=[2,2,6], 
                       C=[3,2,3]))

df['col_total']     = df.apply(lambda x: x.sum(), axis=1)
df.loc['row_total'] = df.apply(lambda x: x.sum())

df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>col_total</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2</td>
      <td>2</td>
      <td>3</td>
      <td>7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>2</td>
      <td>2</td>
      <td>10</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>6</td>
      <td>3</td>
      <td>12</td>
    </tr>
    <tr>
      <th>row_total</th>
      <td>11</td>
      <td>10</td>
      <td>8</td>
      <td>29</td>
    </tr>
  </tbody>
</table>
</div>



Check memory usage


```python
df.memory_usage(deep=True)
```




    Index        170
    A             32
    B             32
    C             32
    col_total     32
    dtype: int64



Cumulative sum


```python
df = pd.DataFrame(dict(A=[2,6,3],
                       B=[2,2,6], 
                       C=[3,2,3]))

df['cumulative_sum'] = df['A'].cumsum()
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>cumulative_sum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2</td>
      <td>2</td>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6</td>
      <td>2</td>
      <td>2</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>6</td>
      <td>3</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



Crosstab  
When you need to count the frequencies for groups formed by 3+ features, pd.crosstab() can make your life easier.


```python
df = pd.DataFrame(dict(
    departure=['SFO', 'SFO', 'LAX', 'LAX', 'JFK', 'SFO'],
    arrival=['ORD', 'DFW', 'DFW', 'ATL', 'ATL', 'ORD'],
    airlines=['Delta', 'JetBlue', 'Delta', 'AA', 'SoutWest', 'Delta']
))

pd.crosstab(
    index=[df['departure'], df['airlines']],
    columns=[df['arrival']],
    rownames=['departure', 'airlines'],
    colnames=['arrival'],
    margins=True # add subtotal
)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>arrival</th>
      <th>ATL</th>
      <th>DFW</th>
      <th>ORD</th>
      <th>All</th>
    </tr>
    <tr>
      <th>departure</th>
      <th>airlines</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>JFK</th>
      <th>SoutWest</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">LAX</th>
      <th>AA</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Delta</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">SFO</th>
      <th>Delta</th>
      <td>0</td>
      <td>0</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <th>JetBlue</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>All</th>
      <th></th>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>



[credits for this tip: Shiu-Tang Li](https://towardsdatascience.com/10-python-pandas-tricks-to-make-data-analysis-more-enjoyable-cb8f55af8c30)
